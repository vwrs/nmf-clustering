<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>FSD Matrix</title>
<style>


.background {
  fill: #eee;
}

.highlight-bar {
  fill: black;
  stroke: white;
  opacity: 0.1;
}

line {
  stroke: #fff;
}



html {
  min-width: 1040px;
}

body {
  background: #fcfcfa;
  color: #333;
  font-family: sans-serif;
  margin: 1em auto 4em auto;
  position: relative;
  width: 960px;
}

header aside,
footer aside {
  float: left;
  margin-right: .5em;
}

header aside:after,
footer aside:after {
  padding-left: .5em;
  content: "/";
}

svg {
  font: 10px sans-serif;
}

text.active {
  fill : red;
}



</style>
<script src="d3.min.js"></script>
<script src="ShortestPathCalculator.js"></script>
<script src="tabletop.js"></script>
<h1>FSD Matrix</h1>

<aside style="margin-top:80px;">
<p>Order: <select id="order">
  <option class="top-level-option" value="name">by Name</option>
  <option class="top-level-option" value="count">by Number of links</option>
  <option class="top-level-option" value="group">by Group</option>
  <option class="top-level-option" value="distance">by Distance to...</option>
</select>



</aside>

<script>

var margin = {top: 150, right: 0, bottom: 10, left: 150},
    width = 1200,
    height = width;
  graph = {"nodes" : [], "links" : [] }

var x = d3.scale.ordinal().rangeBands([0, width]),
  xBoundaryLines = d3.scale.linear();
  yBoundaryLines = d3.scale.linear();
    z = d3.scale.linear().domain([0, 4]).clamp(true),
    c = d3.scale.category10().domain(d3.range(10));

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .style("margin-left", -margin.left + "px")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//data source variables
var public_spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1W-4VOXz4VBYIthILhiMmVm21fvkb3I03cfhdfyiPQIY/pubhtml',
  linksData,
  nodesData;
var loadedLinks = false;
var loadedNodes = false;
var matrix = [];


function getNodeData() {
  nodesData = Tabletop.init(   {   key: public_spreadsheet_url,
            wanted: ["nodes-lisa"],
            callback: processNodesData,
            simpleSheet: true
                    } );
}

function getLinkData() {
    linksData = Tabletop.init(   {   key: public_spreadsheet_url,
            wanted: ["links-lisa"],
            callback: processLinksData,
            simpleSheet: true
                    } );
}

//process the data from Google Sheets into format for D3 graphs
function processNodesData(data) {
  var i;
  for(i = 0; i < data.length; i++) {
    if (data[i]["weight"] == 0 ) {

      //do nothing
    } else {
      graph.nodes.push({ "name": data[i]["name"], "group": data[i]["group"], "distancetocentre": 1, "centre": false, "fixed": false });
    };

  };
  loadedNodes = true;
  drawGraphIfComplete();
}

function processLinksData(data) {
  var i;
  for(i = 0; i < data.length; i++) {
    graph.links.push({ "source": data[i]["source"], "target": data[i]["target"], "distance": +data[i]["value"] });

    for(var j = 0; j < graph.nodes.length; j++) {
      if (graph.links[i].source === graph.nodes[j].name) {
        graph.links[i].source = j;
      }
      if (graph.links[i].target === graph.nodes[j].name) {
        graph.links[i].target = j;
      }
    }
  };

  loadedLinks = true;
  drawGraphIfComplete();
}

function drawGraphIfComplete() {
  console.log(loadedNodes + " " + loadedLinks);
  if (loadedNodes && loadedLinks) {
    console.log("complete");
    drawGraph();
  };
}

function drawGraph() {

  var matrix = [];
  var nodes = graph.nodes;
  var n = nodes.length;
  var boundaryLines = [];

  xBoundaryLines.domain([0,n]);
  xBoundaryLines.range([0,width]);
  yBoundaryLines.domain([0,n]);
  yBoundaryLines.range([0,width]);

  // Compute index per node.
  nodes.forEach(function(node, i) {
    node.index = i;
    node.count = 0;
    matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });
  });

  //fill the drop down menu with names, in alphabetical order

  var select = d3.select("select");
  var selectValues = [];
  graph.nodes.forEach(function (d) {
    selectValues.push(d.name);
  } ) ;

  selectValues.sort();

  select.selectAll("option")
      .data(selectValues, function (d) {return d;}) //uses a key so that the selectValues are appended to the option drop down, assuming that none of the life events/services are called something like "by name"!
      .enter()
        .append("option")
        .attr("value", function (d) {
          return d;
        })
        .text(function (d) { return d; });


  // Convert links to matrix; count character occurrences.
  graph.links.forEach(function(link) {
    matrix[link.source][link.target].z += 1;
    matrix[link.target][link.source].z += 1;
    matrix[link.source][link.source].z += 1;
    matrix[link.target][link.target].z += 1;
    nodes[link.source].count += 1;
    nodes[link.target].count += 1;
  });

  //shortestpath uses the force
  var force = d3.layout.force();
  force.nodes(graph.nodes);
  force.links(graph.links);
  force.start();

  var sp = new ShortestPathCalculator(graph.nodes, graph.links);

  // Precompute the orders.
  var orders = {
    name: d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].name, nodes[b].name); }),
    count: d3.range(n).sort(function(a, b) { return nodes[b].count - nodes[a].count; }),
    group: d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].group, nodes[b].group); }),
  distance: d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].distancetocentre, nodes[b].distancetocentre); })
  };

  // The default sort order.
  x.domain(orders.name);


  //draw some stuff

  svg.append("rect")
    .attr("class", "background")
    .attr("width", width)
    .attr("height", height);

  //line function for drawing boundary lines
  var lineFunction = d3.svg.line()
    .x(function(d) {
      return xBoundaryLines(d.x);
    })
    .y(function(d) {
      return yBoundaryLines(d.y);
    })
    .interpolate("linear");

  var row = svg.selectAll(".row")
      .data(matrix)
    .enter().append("g")
      .attr("class", "row")
    //.attr("class", function(d, i) {return nodes[i].name; }
      .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
      .each(row);

  row.append("line")
      .attr("x2", width);

   row.append("rect")
    .attr("class", "highlightBlock")
    .attr("x", -margin.left)
        .attr("width", margin.left)
        .attr("height", x.rangeBand())
    .style("fill", function (d, i) {

      return (nodes[i].group === "Services") ? "White" : "LightGray";

    });

  row.append("text")
      .attr("x", -10)
      .attr("y", x.rangeBand() / 2)
      .attr("dy", ".32em")
      .attr("text-anchor", "end")
    .style("font-weight", function (d, i) {

      return (nodes[i].group === "Services") ? "normal" : "bold";

    })
      .text(function(d, i) { return nodes[i].name; });

  var column = svg.selectAll(".column")
      .data(matrix)
    .enter().append("g")
      .attr("class", "column")
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

  column.append("line")
      .attr("x1", -width);

  column.append("rect")
    .attr("class", "highlightBlock")
    .attr("x", 0)
        .attr("width", margin.top)
        .attr("height", x.rangeBand())
    .style("fill", function (d, i) {

      return (nodes[i].group === "Services") ? "White" : "LightGray";

    });

  column.append("text")
      .attr("x", 10)
      .attr("y", x.rangeBand() / 2)
      .attr("dy", ".32em")
      .attr("text-anchor", "start")
      .style("font-weight", function (d, i) {
        return (nodes[i].group === "Services") ? "normal" : "bold";
      })
      .text(function(d, i) { return nodes[i].name; });

  function row(row) {
    var cell = d3.select(this).selectAll(".cell")
      .data(row.filter(function(d) { return d.z; }))
      .enter().append("rect")
      .attr("class", "cell")
      .attr("x", function(d) { return x(d.x); })
      .attr("width", x.rangeBand())
      .attr("height", x.rangeBand())
      //.style("fill-opacity", function(d) { return z(d.z); })
      .style("fill", "MediumBlue")
      .on("mouseover", mouseover)
      .on("mouseout", mouseout);
  }

  var boundaryLinesG = svg.append("g")
    .attr("class", "boundaryLinesG")
    .attr("width", width)
    .attr("height", height);

  function mouseover(p) {

    d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
    d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });

  svg.append("rect")
    .attr("x",0)
    .attr("y", x(p.y))
    .attr("class", "highlight-bar")
    .attr("width", x(p.x))
    .attr("height", x.rangeBand());

  svg.append("rect")
    .attr("x", x(p.x))
    .attr("y",0)
    .attr("class", "highlight-bar")
    .attr("width", x.rangeBand())
    .attr("height", x(p.y));

  }

  function mouseout() {

    d3.selectAll("text").classed("active", false);
  d3.selectAll(".highlight-bar").remove();

  }

  d3.select("#order").on("change", function() {
    order(this.value);
  });

  //reorder everthing based on selection from drop down
  function order(value) {

  if (value === "name" || value === "count" || value === "group") {

    x.domain(orders[value]);

    //d3.selectAll(".boundaryLines").remove();
    var t = svg.transition().duration(1500);

    t.selectAll(".boundaryLines").attr("opacity", 0);

    t.selectAll(".row")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
      .selectAll(".cell")
      .delay(function(d) { return x(d.x) * 4; })
      .attr("x", function(d) { return x(d.x); });

    t.selectAll(".column")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

    t.selectAll(".boundaryLines").remove();

  } else if (value === "distance") { alert("Please choose a life event from the list below.");

  } else { //chosen life event or service from the drop down, so reorder based on distance to chosen life event / service

    //console.log(value);

    //reset distances count array

    boundaryLines = [];
    for (i = 0; i < n; i++) {
      boundaryLines.push(0);
    }
    //console.log("1: " + boundaryLines);

    //get the ID of the chosen node
    chosenNodeID = 0;
    nodes.forEach(function(d) { if (d.name === value) { chosenNodeID = d.index; } ; });

    //calculate distances from each node to chosen node
    //update distances count array
    nodes.forEach(function (d, i) {
      var route = sp.findRoute(d.index, chosenNodeID);
      d.distancetocentre = route.distance;
      boundaryLines[d.distancetocentre]++;

    });

    //remove any zero value groups
    //console.log("2: " + boundaryLines);

    var i;
    while (( i = boundaryLines.indexOf(0)) !== -1) {
            boundaryLines.splice(i, 1);
        };

    //console.log("3: " + boundaryLines);

    //sort rows, cells, columns
    orders["distance"] = d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].distancetocentre, nodes[b].distancetocentre); });

    x.domain(orders["distance"]);

    var t1 = svg.transition().duration(1500);
    //remove any boundary lines if they exist
    t1.selectAll(".boundaryLines").attr("opacity", 0);
    t1.selectAll(".boundaryLines").remove();

    t1.selectAll(".row")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
      .selectAll(".cell")
      .delay(function(d) { return x(d.x) * 4; })
      .attr("x", function(d) { return x(d.x); });

    t1.selectAll(".column")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

    d3.selectAll(".boundaryLines").remove();

    //draw new boundary lines
    boundaryLines.forEach(function (d, i) {

      if (i != 0 && i != (boundaryLines.length - 1)) {

        var lineData;
        var xyCoord, zeroCoord;

        xyCoord = 0;
        zeroCoord = 0;

        boundaryLines.forEach(function (e, j) {
          if (j <= i) {
            //console.log(j + " - " + i);
            xyCoord += e;
          };
        });

        //console.log("xyCoord for " + i + ": " + xyCoord);

        lineData = [{
          "x": xyCoord,
          "y": zeroCoord
        }, {
          "x": xyCoord,
          "y": xyCoord
        }, {
          "x": zeroCoord,
          "y": xyCoord
        }];

        //console.log(lineData);

        boundaryLinesG.append("path")
          .attr("d", lineFunction(lineData))
          .classed("boundaryLines", true)
          .attr("stroke", "DarkGray")
          .attr("stroke-width", 2)
          .attr("fill", "none")
          .attr("opacity", 0);



      };
    });

    var t2 = t1.transition();
    t2.selectAll(".boundaryLines").attr("opacity", 1);

  };
  }

};

getNodeData();
getLinkData();

</script>
ShortestPathCalculator.js#
/*
 *
 * Dijkstra Short Path Calculator and Graph Plotter
 * Uses D3 JS (V3)
 *
 */

var ShortestPathCalculator = function(nodes, paths) {

  this.nodes = nodes; // nodes => [ { index: 0, value: 'a', r: 20 }, ... ]
  this.paths = paths; // paths => [ { source: 0, target: 1, distance: 150 }, ... ]
  this.distances = []; // [ [ x, 100, 150 ], [ 100, x, 10] ]
  this.graph = {};

  /*console.log("sp paths");
  console.log(this.paths);
  console.log("sp nodes");
  console.log(this.nodes);*/

  var maxNodes = 1000; //updated from 100
  var minNodes = 3;

  if(!d3) throw new ShortestPathCalculator.SpcError(10, 'D3 library not found');

  if(!nodes.length || nodes.length > maxNodes || nodes.length < minNodes)
    throw new ShortestPathCalculator.SpcError(11, 'Nodes format invalid => ' + JSON.stringify(nodes) );

}

ShortestPathCalculator.isInteger = function(i) {
  return /^\d+$/.test(i);
}

ShortestPathCalculator.SpcError = function(code, message) {
  console.log(message);
  //alert(message);
  return { code: code, message: message };
}

ShortestPathCalculator.prototype.findRoute = function(source, target) {

  if(!ShortestPathCalculator.isInteger(source) || !ShortestPathCalculator.isInteger(target))
    throw new ShortestPathCalculator.SpcError(20, "Source and target must be ints");

  if(source > this.nodes.length - 1|| target > this.nodes.length - 1)
    throw new ShortestPathCalculator.SpcError(21, "Source or target put of range");

  this.makeDistanceArrayFromNodes();

  this.populateDistances();

  this.result = this.dijkstra(source, target);

  return this.result;

}

ShortestPathCalculator.prototype.makeDistanceArrayFromNodes = function() {

  this.distances = [];

  for(var i=0; i<this.nodes.length; i++) {

    this.distances[i] = [];

    for(var j=0; j<this.nodes.length; j++){
      this.distances[i][j] = 'x';
    }
  }

}

ShortestPathCalculator.prototype.populateDistances = function() {

  for(var i=0; i<this.paths.length; i++) {

    var s = parseInt(this.paths[i].source.index);
    var t = parseInt(this.paths[i].target.index);
    var d = parseInt(this.paths[i].distance);

    this.distances[s][t] = d;
    this.distances[t][s] = d;
  }

}

ShortestPathCalculator.clearDiv = function(elementId) {
  var target = document.getElementById(elementId);

  if(!target) return -1;

  while(target.firstChild)
    target.removeChild(target.firstChild);

  return target;
}

ShortestPathCalculator.prototype.makeSVG = function(elementId, width, height) {

  this.graph.width  = width  ? width  : 800;
  this.graph.height = height ? height : 400;

  ShortestPathCalculator.clearDiv(elementId);

  var target = d3.select('#' + elementId);

  this.graph.svg = target.append("svg:svg")
    .attr("width", this.graph.width)
    .attr("height", this.graph.height);

}

ShortestPathCalculator.prototype.drawGraph = function(elementId, width, height) {

  if(!this.graph.svg)
    this.makeSVG(elementId, width, height);

  var that = this;

  this.nodes.forEach(function(d, i) { d.x = d.y = that.graph.width / that.nodes.length * i});

  var force = d3.layout.force()
    .nodes(this.nodes)
    .links(this.paths)
    .charge(-500)
    .linkDistance(function(d){ return d.distance; })
    .size([this.graph.width, this.graph.height]);

  force.on("tick", function(e) {
    that.graph.svg.selectAll("path")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });

  var j = this.nodes.length*20;
  force.start();
  for (var i = j * j; i > 0; --i) force.tick();
  force.stop();

  this.graph.svg.selectAll("line")
    .data(this.paths)
    .enter()
      .append("line")
        .attr("class", function(d) {
          if(that.result.path !== null) {
            for (var i = 0; i < that.result.path.length; i++) {
              if ((that.result.path[i].source === d.source.index && that.result.path[i].target === d.target.index)
               || (that.result.path[i].source === d.target.index && that.result.path[i].target === d.source.index))
                return 'link bold';
            }
          }
          return 'link';
        })
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

  this.graph.svg.append("svg:g")
    .selectAll("circle")
      .data(this.nodes)
      .enter()
        .append("svg:circle")
          .attr("class", "node")
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; })
          .attr("r",  function(d) { return 15; });

  this.graph.svg.append("svg:g")
    .selectAll("text")
      .data(this.nodes)
      .enter()
        .append("svg:text")
          .attr("class", "label")
          .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
          .attr("text-anchor", "middle")
          .attr("y", ".3em")
          .text(function(d) { return d.value; });

}

ShortestPathCalculator.prototype.formatResult = function() {

  // result => {mesg:"OK", path:[0, 1, 4], distance:250}

  var res = "";

  res += "<p>Result : " + this.result.mesg + "</p>";

  if(this.result.path === null)
    return "<p>No path found from " + this.result.source + " to " + this.result.target + "</p>";

  if(this.result.path.length === 0)
    return "<p>Path is from " + SpUtils.nodeNames[this.result.source] + " to "
      + SpUtils.nodeNames[this.result.target] + ". Expect a journey time of approximately zero.</p>"

  res += "<p>Path   : ";

  for(var i=0; i<this.result.path.length; i++) {
    var sourceNodeIndex = this.result.path[i].source;
    var targetNodeIndex = this.result.path[i].target;
    var sourceNode = this.nodes[sourceNodeIndex];
    var targetNode = this.nodes[targetNodeIndex];
    res += ' ' + sourceNode.value + ' -> ' + targetNode.value;
  }
  res += "</p>";
  res += "<p>Distance : " + this.result.distance + "</p>";

  return res;

}

/*
 *
 * Calculate shortest path between two nodes in a graph
 *
 * @param {Integer} start     index of node to start from
 * @param {Integer} end       index of node to end at
 *
 */

ShortestPathCalculator.prototype.dijkstra = function(start, end) {

    var nodeCount = this.distances.length,
        infinity = 99999,  // larger than largest distance in distances array
        shortestPath = new Array(nodeCount),
        nodeChecked  = new Array(nodeCount),
        pred         = new Array(nodeCount);

    // initialise data placeholders

    for(var i=0; i<nodeCount; i++) {
        shortestPath[i] = infinity;
        pred[i]=null;
        nodeChecked[i]=false;
    }

    shortestPath[start]=0;

    for(var i=0; i<nodeCount; i++) {

        var minDist = infinity;
        var closestNode = null;

        for (var j=0; j<nodeCount; j++) {

            if(!nodeChecked[j]) {
                if(shortestPath[j] <= minDist) {
                    minDist = shortestPath[j];
                    closestNode = j;
                }
            }
        }

        nodeChecked[closestNode] = true;

        for(var k=0; k<nodeCount; k++) {
            if(!nodeChecked[k]){
                var nextDistance = distanceBetween(closestNode, k, this.distances);

                if ((parseInt(shortestPath[closestNode]) + parseInt(nextDistance)) < parseInt(shortestPath[k])){
                    soFar = parseInt(shortestPath[closestNode]);
                    extra = parseInt(nextDistance);

                    shortestPath[k] = soFar + extra;

                    pred[k] = closestNode;
                }
            }
        }

    }

    if(shortestPath[end] < infinity) {

        var newPath = [];
        var step    = { target: parseInt(end) };

        var v = parseInt(end);

        //console.log('v');
        //console.log(v);

        while (v>=0) {

            v = pred[v];

            //console.log('v');
            //console.log(v);

            if (v!==null && v>=0) {
                step.source = v;
                newPath.unshift(step);
                step = {target: v};
            }

        }

        totalDistance = shortestPath[end];

        return {mesg:'OK', path: newPath, source: start, target: end, distance:totalDistance};
    }
    else {
        return {mesg:'No path found', path: null, source: start, target: end, distance: 0 };
    }

    function distanceBetween(fromNode, toNode, distances) {

        dist = distances[fromNode][toNode];

        if(dist==='x') dist = infinity;

        return dist;
    }

}
tabletop.js#
(function() {
  "use strict";

  var inNodeJS = false;
  if (typeof process !== 'undefined' && !process.browser) {
    inNodeJS = true;
    var request = require('request'.trim()); //prevents browserify from bundling the module
  }

  var supportsCORS = false;
  var inLegacyIE = false;
  try {
    var testXHR = new XMLHttpRequest();
    if (typeof testXHR.withCredentials !== 'undefined') {
      supportsCORS = true;
    } else {
      if ("XDomainRequest" in window) {
        supportsCORS = true;
        inLegacyIE = true;
      }
    }
  } catch (e) { }

  // Create a simple indexOf function for support
  // of older browsers.  Uses native indexOf if
  // available.  Code similar to underscores.
  // By making a separate function, instead of adding
  // to the prototype, we will not break bad for loops
  // in older browsers
  var indexOfProto = Array.prototype.indexOf;
  var ttIndexOf = function(array, item) {
    var i = 0, l = array.length;

    if (indexOfProto && array.indexOf === indexOfProto) return array.indexOf(item);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  /*
    Initialize with Tabletop.init( { key: '0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc' } )
      OR!
    Initialize with Tabletop.init( { key: 'https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc&output=html&widget=true' } )
      OR!
    Initialize with Tabletop.init('0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc')
  */

  var Tabletop = function(options) {
    // Make sure Tabletop is being used as a constructor no matter what.
    if(!this || !(this instanceof Tabletop)) {
      return new Tabletop(options);
    }

    if(typeof(options) === 'string') {
      options = { key : options };
    }

    this.callback = options.callback;
    this.wanted = options.wanted || [];
    this.key = options.key;
    this.simpleSheet = !!options.simpleSheet;
    this.parseNumbers = !!options.parseNumbers;
    this.wait = !!options.wait;
    this.reverse = !!options.reverse;
    this.postProcess = options.postProcess;
    this.debug = !!options.debug;
    this.query = options.query || '';
    this.orderby = options.orderby;
    this.endpoint = options.endpoint || "https://spreadsheets.google.com";
    this.singleton = !!options.singleton;
    this.simple_url = !!options.simple_url;
    this.callbackContext = options.callbackContext;
    // Default to on, unless there's a proxy, in which case it's default off
    this.prettyColumnNames = typeof(options.prettyColumnNames) == 'undefined' ? !options.proxy : options.prettyColumnNames

    if(typeof(options.proxy) !== 'undefined') {
      // Remove trailing slash, it will break the app
      this.endpoint = options.proxy.replace(/\/$/,'');
      this.simple_url = true;
      this.singleton = true;
      // Let's only use CORS (straight JSON request) when
      // fetching straight from Google
      supportsCORS = false;
    }

    this.parameterize = options.parameterize || false;

    if(this.singleton) {
      if(typeof(Tabletop.singleton) !== 'undefined') {
        this.log("WARNING! Tabletop singleton already defined");
      }
      Tabletop.singleton = this;
    }

    /* Be friendly about what you accept */
    if(/key=/.test(this.key)) {
      this.log("You passed an old Google Docs url as the key! Attempting to parse.");
      this.key = this.key.match("key=(.*?)(&|#|$)")[1];
    }

    if(/pubhtml/.test(this.key)) {
      this.log("You passed a new Google Spreadsheets url as the key! Attempting to parse.");
      this.key = this.key.match("d\\/(.*?)\\/pubhtml")[1];
    }

    if(!this.key) {
      this.log("You need to pass Tabletop a key!");
      return;
    }

    this.log("Initializing with key " + this.key);

    this.models = {};
    this.model_names = [];

    this.base_json_path = "/feeds/worksheets/" + this.key + "/public/basic?alt=";

    if (inNodeJS || supportsCORS) {
      this.base_json_path += 'json';
    } else {
      this.base_json_path += 'json-in-script';
    }

    if(!this.wait) {
      this.fetch();
    }
  };

  // A global storage for callbacks.
  Tabletop.callbacks = {};

  // Backwards compatibility.
  Tabletop.init = function(options) {
    return new Tabletop(options);
  };

  Tabletop.sheets = function() {
    this.log("Times have changed! You'll want to use var tabletop = Tabletop.init(...); tabletop.sheets(...); instead of Tabletop.sheets(...)");
  };

  Tabletop.prototype = {

    fetch: function(callback) {
      if(typeof(callback) !== "undefined") {
        this.callback = callback;
      }
      this.requestData(this.base_json_path, this.loadSheets);
    },

    /*
      This will call the environment appropriate request method.

      In browser it will use JSON-P, in node it will use request()
    */
    requestData: function(path, callback) {
      if (inNodeJS) {
        this.serverSideFetch(path, callback);
      } else {
        //CORS only works in IE8/9 across the same protocol
        //You must have your server on HTTPS to talk to Google, or it'll fall back on injection
        var protocol = this.endpoint.split("//").shift() || "http";
        if (supportsCORS && (!inLegacyIE || protocol === location.protocol)) {
          this.xhrFetch(path, callback);
        } else {
          this.injectScript(path, callback);
        }
      }
    },

    /*
      Use Cross-Origin XMLHttpRequest to get the data in browsers that support it.
    */
    xhrFetch: function(path, callback) {
      //support IE8's separate cross-domain object
      var xhr = inLegacyIE ? new XDomainRequest() : new XMLHttpRequest();
      xhr.open("GET", this.endpoint + path);
      var self = this;
      xhr.onload = function() {
        try {
          var json = JSON.parse(xhr.responseText);
        } catch (e) {
          console.error(e);
        }
        callback.call(self, json);
      };
      xhr.send();
    },

    /*
      Insert the URL into the page as a script tag. Once it's loaded the spreadsheet data
      it triggers the callback. This helps you avoid cross-domain errors
      http://code.google.com/apis/gdata/samples/spreadsheet_sample.html

      Let's be plain-Jane and not use jQuery or anything.
    */
    injectScript: function(path, callback) {
      var script = document.createElement('script');
      var callbackName;

      if(this.singleton) {
        if(callback === this.loadSheets) {
          callbackName = 'Tabletop.singleton.loadSheets';
        } else if (callback === this.loadSheet) {
          callbackName = 'Tabletop.singleton.loadSheet';
        }
      } else {
        var self = this;
        callbackName = 'tt' + (+new Date()) + (Math.floor(Math.random()*100000));
        // Create a temp callback which will get removed once it has executed,
        // this allows multiple instances of Tabletop to coexist.
        Tabletop.callbacks[ callbackName ] = function () {
          var args = Array.prototype.slice.call( arguments, 0 );
          callback.apply(self, args);
          script.parentNode.removeChild(script);
          delete Tabletop.callbacks[callbackName];
        };
        callbackName = 'Tabletop.callbacks.' + callbackName;
      }

      var url = path + "&callback=" + callbackName;

      if(this.simple_url) {
        // We've gone down a rabbit hole of passing injectScript the path, so let's
        // just pull the sheet_id out of the path like the least efficient worker bees
        if(path.indexOf("/list/") !== -1) {
          script.src = this.endpoint + "/" + this.key + "-" + path.split("/")[4];
        } else {
          script.src = this.endpoint + "/" + this.key;
        }
      } else {
        script.src = this.endpoint + url;
      }

      if (this.parameterize) {
        script.src = this.parameterize + encodeURIComponent(script.src);
      }

      document.getElementsByTagName('script')[0].parentNode.appendChild(script);
    },

    /*
      This will only run if tabletop is being run in node.js
    */
    serverSideFetch: function(path, callback) {
      var self = this
      request({url: this.endpoint + path, json: true}, function(err, resp, body) {
        if (err) {
          return console.error(err);
        }
        callback.call(self, body);
      });
    },

    /*
      Is this a sheet you want to pull?
      If { wanted: ["Sheet1"] } has been specified, only Sheet1 is imported
      Pulls all sheets if none are specified
    */
    isWanted: function(sheetName) {
      if(this.wanted.length === 0) {
        return true;
      } else {
        return (ttIndexOf(this.wanted, sheetName) !== -1);
      }
    },

    /*
      What gets send to the callback
      if simpleSheet === true, then don't return an array of Tabletop.this.models,
      only return the first one's elements
    */
    data: function() {
      // If the instance is being queried before the data's been fetched
      // then return undefined.
      if(this.model_names.length === 0) {
        return undefined;
      }
      if(this.simpleSheet) {
        if(this.model_names.length > 1 && this.debug) {
          this.log("WARNING You have more than one sheet but are using simple sheet mode! Don't blame me when something goes wrong.");
        }
        return this.models[ this.model_names[0] ].all();
      } else {
        return this.models;
      }
    },

    /*
      Add another sheet to the wanted list
    */
    addWanted: function(sheet) {
      if(ttIndexOf(this.wanted, sheet) === -1) {
        this.wanted.push(sheet);
      }
    },

    /*
      Load all worksheets of the spreadsheet, turning each into a Tabletop Model.
      Need to use injectScript because the worksheet view that you're working from
      doesn't actually include the data. The list-based feed (/feeds/list/key..) does, though.
      Calls back to loadSheet in order to get the real work done.

      Used as a callback for the worksheet-based JSON
    */
    loadSheets: function(data) {
      var i, ilen;
      var toLoad = [];
      this.googleSheetName = data.feed.title.$t;
      this.foundSheetNames = [];

      for(i = 0, ilen = data.feed.entry.length; i < ilen ; i++) {
        this.foundSheetNames.push(data.feed.entry[i].title.$t);
        // Only pull in desired sheets to reduce loading
        if( this.isWanted(data.feed.entry[i].content.$t) ) {
          var linkIdx = data.feed.entry[i].link.length-1;
          var sheet_id = data.feed.entry[i].link[linkIdx].href.split('/').pop();
          var json_path = "/feeds/list/" + this.key + "/" + sheet_id + "/public/values?alt="
          if (inNodeJS || supportsCORS) {
            json_path += 'json';
          } else {
            json_path += 'json-in-script';
          }
          if(this.query) {
            json_path += "&sq=" + this.query;
          }
          if(this.orderby) {
            json_path += "&orderby=column:" + this.orderby.toLowerCase();
          }
          if(this.reverse) {
            json_path += "&reverse=true";
          }
          toLoad.push(json_path);
        }
      }

      this.sheetsToLoad = toLoad.length;
      for(i = 0, ilen = toLoad.length; i < ilen; i++) {
        this.requestData(toLoad[i], this.loadSheet);
      }
    },

    /*
      Access layer for the this.models
      .sheets() gets you all of the sheets
      .sheets('Sheet1') gets you the sheet named Sheet1
    */
    sheets: function(sheetName) {
      if(typeof sheetName === "undefined") {
        return this.models;
      } else {
        if(typeof(this.models[ sheetName ]) === "undefined") {
          // alert( "Can't find " + sheetName );
          return;
        } else {
          return this.models[ sheetName ];
        }
      }
    },

    sheetReady: function(model) {
      this.models[ model.name ] = model;
      if(ttIndexOf(this.model_names, model.name) === -1) {
        this.model_names.push(model.name);
      }

      this.sheetsToLoad--;
      if(this.sheetsToLoad === 0)
        this.doCallback();
    },

    /*
      Parse a single list-based worksheet, turning it into a Tabletop Model

      Used as a callback for the list-based JSON
    */
    loadSheet: function(data) {
      var that = this;
      var model = new Tabletop.Model( { data: data,
                                        parseNumbers: this.parseNumbers,
                                        postProcess: this.postProcess,
                                        tabletop: this,
                                        prettyColumnNames: this.prettyColumnNames,
                                        onReady: function() {
                                          that.sheetReady(this);
                                        } } );
    },

    /*
      Execute the callback upon loading! Rely on this.data() because you might
        only request certain pieces of data (i.e. simpleSheet mode)
      Tests this.sheetsToLoad just in case a race condition happens to show up
    */
    doCallback: function() {
      if(this.sheetsToLoad === 0) {
        this.callback.apply(this.callbackContext || this, [this.data(), this]);
      }
    },

    log: function(msg) {
      if(this.debug) {
        if(typeof console !== "undefined" && typeof console.log !== "undefined") {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
    }

  };

  /*
    Tabletop.Model stores the attribute names and parses the worksheet data
      to turn it into something worthwhile

    Options should be in the format { data: XXX }, with XXX being the list-based worksheet
  */
  Tabletop.Model = function(options) {
    var i, j, ilen, jlen;
    this.column_names = [];
    this.name = options.data.feed.title.$t;
    this.tabletop = options.tabletop;
    this.elements = [];
    this.onReady = options.onReady;
    this.raw = options.data; // A copy of the sheet's raw data, for accessing minutiae

    if(typeof(options.data.feed.entry) === 'undefined') {
      options.tabletop.log("Missing data for " + this.name + ", make sure you didn't forget column headers");
      this.original_columns = [];
      this.elements = [];
      this.onReady.call(this);
      return;
    }

    for(var key in options.data.feed.entry[0]){
      if(/^gsx/.test(key))
        this.column_names.push( key.replace("gsx$","") );
    }

    this.original_columns = this.column_names;

    for(i = 0, ilen =  options.data.feed.entry.length ; i < ilen; i++) {
      var source = options.data.feed.entry[i];
      var element = {};
      for(var j = 0, jlen = this.column_names.length; j < jlen ; j++) {
        var cell = source[ "gsx$" + this.column_names[j] ];
        if (typeof(cell) !== 'undefined') {
          if(options.parseNumbers && cell.$t !== '' && !isNaN(cell.$t))
            element[ this.column_names[j] ] = +cell.$t;
          else
            element[ this.column_names[j] ] = cell.$t;
        } else {
            element[ this.column_names[j] ] = '';
        }
      }
      if(element.rowNumber === undefined)
        element.rowNumber = i + 1;
      if( options.postProcess )
        options.postProcess(element);
      this.elements.push(element);
    }

    if(options.prettyColumnNames)
      this.fetchPrettyColumns();
    else
      this.onReady.call(this);
  };

  Tabletop.Model.prototype = {
    /*
      Returns all of the elements (rows) of the worksheet as objects
    */
    all: function() {
      return this.elements;
    },

    fetchPrettyColumns: function() {
      if(!this.raw.feed.link[3])
        return this.ready();
      var cellurl = this.raw.feed.link[3].href.replace('/feeds/list/', '/feeds/cells/').replace('https://spreadsheets.google.com', '');
      var that = this;
      this.tabletop.requestData(cellurl, function(data) {
        that.loadPrettyColumns(data)
      });
    },

    ready: function() {
      this.onReady.call(this);
    },

    /*
     * Store column names as an object
     * with keys of Google-formatted "columnName"
     * and values of human-readable "Column name"
     */
    loadPrettyColumns: function(data) {
      var pretty_columns = {};

      var column_names = this.column_names;

      var i = 0;
      var l = column_names.length;

      for (; i < l; i++) {
        if (typeof data.feed.entry[i].content.$t !== 'undefined') {
          pretty_columns[column_names[i]] = data.feed.entry[i].content.$t;
        } else {
          pretty_columns[column_names[i]] = column_names[i];
        }
      }

      this.pretty_columns = pretty_columns;

      this.prettifyElements();
      this.ready();
    },

    /*
     * Go through each row, substitutiting
     * Google-formatted "columnName"
     * with human-readable "Column name"
     */
    prettifyElements: function() {
      var pretty_elements = [],
          ordered_pretty_names = [],
          i, j, ilen, jlen;

      var ordered_pretty_names;
      for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {
        ordered_pretty_names.push(this.pretty_columns[this.column_names[j]]);
      }

      for(i = 0, ilen = this.elements.length; i < ilen; i++) {
        var new_element = {};
        for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {
          var new_column_name = this.pretty_columns[this.column_names[j]];
          new_element[new_column_name] = this.elements[i][this.column_names[j]];
        }
        pretty_elements.push(new_element);
      }
      this.elements = pretty_elements;
      this.column_names = ordered_pretty_names;
    },

    /*
      Return the elements as an array of arrays, instead of an array of objects
    */
    toArray: function() {
      var array = [],
          i, j, ilen, jlen;
      for(i = 0, ilen = this.elements.length; i < ilen; i++) {
        var row = [];
        for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {
          row.push( this.elements[i][ this.column_names[j] ] );
        }
        array.push(row);
      }
      return array;
    }
  };

  if(typeof module !== "undefined" && module.exports) { //don't just use inNodeJS, we may be in Browserify
    module.exports = Tabletop;
  } else if (typeof define === 'function' && define.amd) {
    define(function () {
        return Tabletop;
    });
  } else {
    window.Tabletop = Tabletop;
  }

})();
